## ì´ë¯¸ì§€ ì—…ë¡œë“œ & ë‹¤ìš´ë¡œë“œ

***URLSession Download Task ì´ìš©í•´ì„œ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ***

âœ”ï¸ ìºì‹œì— ìˆëŠ” ê²½ìš° ë‹¤ìš´ë¡œë“œ í•˜ì§€ ì•ŠìŒ & ìºì‹œì— ì—†ëŠ” ê²½ìš° ë‹¤ìš´ë¡œë“œ ì‹¤í–‰

 DownloadTaskì„ ì´ìš©í•´ì„œ ë‹¤ìš´ë¡œë“œë¥¼ ë°›ì„ ë•Œ, ì™„ë£Œ í›„ ì¼ì‹œì ì¸ ê³µê°„ì— í•´ë‹¹ íŒŒì¼ì´ ì €ì¥ë˜ê²Œ ëœë‹¤. ì´ë¥¼ ë³´ê´€í•˜ê¸°ë¥¼ ì›í•œë‹¤ë©´ ê¼­ Handlerê°€ ëë‚˜ê¸° ì „ì— ë‹¤ë¥¸ ê³µê°„ì— ì €ì¥í•´ì•¼í•œë‹¤.

 ì—¬ê¸°ì„œ Downloadì„ ë°›ëŠ” ë™ì•ˆ ì§„í–‰ê³¼ì •ì— ëŒ€í•œ ì—…ë°ì´íŠ¸ë¥¼ ë°›ê¸°ë¥¼ ì›í•˜ë©´ ê¼­ `URLSessionTaskDelegate`, `URLSessionDownloadDelegate`ì„ ì‚¬ìš©í•˜ì—¬ì•¼ í•œë‹¤.

 ìš°ì„  URLSessionì— ëŒ€í•œ ìƒì„±ì´ í•„ìš”í•˜ë‹¤.

```swift
class FriendViewController: UIViewController {
  // Delegate ì§€ì •ì„ ìœ„í•´ Lazyë¡œ ì„ ì–¸
  lazy var downloadSession: URLSession = {
        let configutaion = URLSessionConfiguration.default
        return URLSession(configuration: configutaion, delegate: self, delegateQueue: nil)
    }()
}

extension FriendViewController: URLSessionTaskDelegate, URLSessionDownloadDelegate {
  // Donwload Taskê°€ ì™„ë£Œëœ í›„ì— ë¶ˆë¦¬ëŠ” ë©”ì†Œë“œ
  func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {
    print(location.absoluteURL)
  }
  
  // Download Taskê°€ ì§„í–‰ë˜ëŠ” ë™ì•ˆ ì§„í–‰ìƒí™©ì„ ë‚˜íƒ€ë‚´ëŠ” ë©”ì†Œë“œ
  func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {
    let calculatedProgress = Float(totalBytesWritten) / Float(totalBytesExpectedToWrite)
    print(calculatedProgress)
  }
}
```

<br>

ê¸°ë³¸ì ì¸ URLSessionì„ ìƒì„±í•˜ê³  ì…‹íŒ…í•œ ë°©ë²•ì´ë‹¤. ì´í›„ Request ë°©ì‹ì„ ì„¤ì •í•˜ê³  í†µì‹ ì„ í•˜ëŠ” ê³¼ì •ì´ í•„ìš”í•˜ë‹¤.

1ï¸âƒ£ URLSession

> í†µì‹ ì„ í•˜ëŠ” í° ë°©ë²•ì´ë‹¤. 3ê°€ì§€ë¥¼ ì§€ì›í•œë‹¤.

2ï¸âƒ£ URLRequest

> ì„œë²„ë¡œ ìš”ì²­ì„ ë³´ë‚¼ ë•Œ,ì–´ë–¤ ë°©ì‹ìœ¼ë¡œ ë³´ë‚¼ì§€ ì–´ë–¤ HTTP ë©”ì†Œë“œë¥¼ ì‚¬ìš©í•  ê²ƒì¸ì§€ ì–´ë–¤ ë‚´ìš©ì„ ë³´ë‚¼ì§€ë¥¼ ì„¤ì •í•  ìˆ˜ ìˆëŠ” ê°ì²´ì´ë‹¤.

3ï¸âƒ£ Task

> ê°ì²´ê°€ ì„œë²„ë¡œ ìš”ì²­ì„ ë³´ë‚¸ í›„, ì‘ë‹µì„ ë°›ì„ ë•Œ URL ê¸°ë°˜ì˜ ë‚´ìš©ë“¤ì„ ë°›ëŠ” ì—­í• ì„ í•©ë‹ˆë‹¤. 3ê°€ì§€ ì¢…ë¥˜ì˜ Taskê°€ ì§€ì›ëœë‹¤.
>
> ğŸ‘‰ Data Task
>
> ğŸ‘‰ Download Task
>
> ğŸ‘‰ Upload Task

<br>

âœ”ï¸ URLRequest ì„¸íŒ…í•˜ëŠ” ë²•

```swift
// HTTP MethodëŠ” POST ë°©ì‹ìœ¼ë¡œ í†µì‹ 
// Header Typeì€ JSON í˜•ì‹ìœ¼ë¡œ ì£¼ê³  ë°›ìŒ
let url = URL(string: "https://example.com/post")!
var request = URLRequest(url: url)
request.httpMethod = "POST"
request.setValue("application/json", forHTTPHeaderField: "Content-Type")
```

<br>

 ë‹¤ìš´ë¡œë“œë¥¼ ì²˜ë¦¬í•´ ì¤„, DownloadService ê°ì²´ë¥¼ ìƒì„± í›„, URLSessionì˜ DownloadTaskì„ í™œìš©í•´ êµ¬í˜„í•˜ì˜€ë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ DownloadTaskì„ í™œìš©í•´ ë‹¤ìš´ì´ ë°›ì•„ì§€ëŠ” íŒŒì¼ë“¤ì˜ ìœ„ì¹˜ë¥¼ ë³´ë©´ tmpì— ë‹¤ìš´ì´ ë˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤. ì´ë¥¼ Cacheë¡œ ì €ì¥ì„ í•˜ê³  Cacheì— ìˆì„ ì‹œ DownloadTaskì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì•„ë‹Œ Cacheì—ì„œ ë¶ˆëŸ¬ì™€ì„œ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬ë¥¼ í•˜ë ¤ê³  í•œë‹¤.

```swift
struct DownloadService {
  static let shared = DownloadService()
  
  // completionì—ëŠ” ê° Controllerì—ì„œ ì‚¬ìš©ë˜ëŠ” ë¡œì§ì„ êµ¬í˜„í•´ì„œ ë˜ì ¸ì¤€ í›„, Taskê°€ ì‹¤í–‰ë˜ê³ ë‚œ í›„ ì‹¤í–‰ë˜ê²Œ í•¨.
  func download(from url: String, session: URLSession, completion: @escaping (NetworkResult<Any>) -> Void) {
    guard let url = URL(string: url) else { return }
    let request = URLRequest(url: url)
    var cachePath = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).first
    cachePath?.appendPathComponent(url.lastPathComponent)
    
    let downloadTask = session.downloadTask(with: reqeust) { 
      location, response, error in
      // ë” í•˜ìœ„ ê°œë…ì¸ HTTPResponseë¡œ ìºìŠ¤íŒ…í•˜ì—¬ statusCode í™•ì¸í•˜ì—¬ ë¶„ê¸°ì²˜ë¦¬  
      guard let response = response as? HTTPURLResponse else { return }
      switch response.statusCode {
        // ì„±ê³µì ìœ¼ë¡œ ë°ì´í„°ë¥¼ ë‹¤ìš´ë°›ì•„ì˜¨ ê²½ìš° tmp --> cache í´ë”ë¡œ ë³µì‚¬í•˜ê¸°
        case 200:
        try? FileManager.default.copyItem(at: location!, to: cachePath!)
        complection(.success(cachePath))
        case 400: complection(.pathErr)
        case 500: complection(.serverErr)
        default: complection(.networkFail)
      }
      
      // Cacheì— ìˆëŠ” ê²½ìš°ëŠ” cacheì— ìˆëŠ” íŒŒì¼ ì‚¬ìš©
      // Cacheì— ì—†ëŠ” ê²½ìš°ëŠ” Download Task ì‹¤í–‰
      if !FileManager.default.fileExists(atPath: cachePath!.absoluteString) { downloadTask.resume() }
      else { completion(.success(cachePath!)) }
		}
  }
}
```

<br>

<br>

***KINGFISHER ì´ìš©í•´ì„œ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ***

 ê¸°ë³¸ì ìœ¼ë¡œ **KINGFISHER** ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•´ì„œ ì´ë¯¸ì§€ë¥¼ ë‹¤ìš´ë¡œë“œí•˜ê¸° ìœ„í•´ Cocoapodsì„ ì‚¬ìš©í•´ **KINGFISHER** ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¤ì¹˜ê°€ í•„ìˆ˜ì´ë‹¤. ì—¬ê¸°ì„œëŠ” 5.0 versionì„ ì‚¬ìš©í•˜ì˜€ë‹¤.

```swift
// ì‚¬ìš©í•˜ê¸° ì´ì „ì— í•„ìˆ˜ì´ë‹¤.
import Kingfisher
```

<br>

 ìš°ì„  ìºì‹œì— ì´ë¯¸ì§€ê°€ ìˆëŠ”ì§€ ì—†ëŠ”ì§€ íŒë³„í•´ì„œ ì´ë¯¸ì§€ë¥¼ ë°›ì•„ì˜¤ëŠ” ê²ƒì´ íš¨ìœ¨ì ì´ë‹¤.

âœ”ï¸ ìºì‹œ í™•ì¸ ë²•

```swift
let cache = ImageCache.default
// í•´ë‹¹ Keyì— ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸ í›„ Bool íƒ€ì…ì„ ë°˜í™˜í•œë‹¤.
let cached = cache.isCached(forKey: cacheKey)
// .memory
// .disk
// .none
// ì„¸ ê°€ì§€ íƒ€ì…ì´ í•„ìš”í•˜ë‹¤
let cacheType = cache.imageCachedType(forKey: cacheKey)
```

<br>

 ìœ„ê¹Œì§€ì˜ ë°©ë²•ì´ ìºì‹œì— ìˆëŠ” ë°ì´í„°ë¥¼ í™•ì¸í•˜ëŠ” ë°©ë²•ì´ë‹¤. ì´ì œ ìºì‹œì— ë°ì´í„°ê°€ ìˆëŠ”ì§€ ì—†ëŠ”ì§€ ê²€ì‚¬ í›„, ì´ë¥¼ ê°€ì ¸ì˜¤ê±°ë‚˜ ìºì‹œì— ì—†ëŠ” ê²½ìš°, ë‹¤ìš´ë¡œë“œë¥¼ í•´ì£¼ëŠ” ì‘ì—…ì´ í•„ìš”í•˜ë‹¤. 

âœ”ï¸ ìºì‹œì— ìˆê³  ì—†ëŠ” ê²½ìš° ë¶„ê¸° ì²˜ë¦¬

```swift
let cache = ImageCache.default
// ìºì‹œì—ì„œ í•´ë‹¹ í‚¤ì— ë°ì´í„°ê°€ ìˆëŠ” ê²½ìš° .success ì‹¤í–‰
// ìºì‹œì—ì„œ í•´ë‹¹ í‚¤ì— ë°ì´í„°ê°€ ì—†ëŠ” ê²½ìš° .failure ì‹¤í–‰
cache.retrieveImage(forKey: "cacheKey") { 
  result in
  switch result {
    case .success(let value):
    case .failure(let error):
  }
}
```

<br>

 ìºì‹œì— ë°ì´í„°ê°€ ìˆëŠ”ì§€ ì—†ëŠ”ì§€ ê²€ì‚¬í•´ì„œ Imageì— ì„¸íŒ…í• ì§€ë¥¼ ì •í•˜ëŠ” ì½”ë“œì´ë‹¤.

âœ”ï¸ ì „ì²´ í™œìš©ë²•

```swift
extension UIImageView {
  func setImage(from url: String) {
    let cache = ImageCache.default
    // ì´ë¯¸ì§€ë¥¼ ë°›ì•„ì˜¤ëŠ” ë™ì•ˆ indicator ì‹¤í–‰
    self.kf.indicatorType = .activity
    // ìºì‹œì— ì´ë¯¸ì§€ê°€ ìˆëŠ”ì§€ ì—†ëŠ”ì§€ ê²€ì‚¬í•˜ì—¬ ë¶„ê¸° ì‹¤í–‰
    cache.retrieveImage(forKey: url) { 
      result in
      switch result {
      case .success(let value):
        	switch value.cacheType {
          // ìºì‹œì— ì´ë¯¸ì§€ê°€ ì €ì¥ë˜ì§€ ì•Šì€ ê²½ìš° ë°ì´í„°ë¥¼ ë°›ì•„ì˜´
          // setImageì„ ì‹¤í–‰í•  ê²½ìš° ì•Œì•„ì„œ AbsoluteURLì„ ë³´ê³  ìºì‹œì— í•´ë‹¹ í‚¤ë¡œ ì €ì¥í•œë‹¤.
          case .none: self.kf.setImage(with: URL(string: url)!, placeholder: UIImage(systemName: "pencil"), options: [.transition(.fade(1))])
          case .memory: self.image = value.image
          case .disk: self.image = value.image
          }
      case .failure(let error):
        	print(error.errorCode)
        	self.image = UIImage()
      }
    }
  }
}
```

<br>

<br>

***Multipart-form Data ì‚¬ìš© ì´ë¯¸ì§€ ì—…ë¡œë“œ***

 ìš°ì„  ê¸°ë³¸ì ìœ¼ë¡œ í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì„œë²„ë¡œ íŒŒì¼ì„ ë³´ë‚´ë ¤ë©´ multipart/form-data íƒ€ì…ìœ¼ë¡œ íŒŒì¼ì„ ì „ì†¡í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤. ì´ë•Œ ë³´í†µ í—¤ë”ë¡œ Content-Typeì— application/json í˜•ì‹ì´ ë“¤ì–´ê°€ëŠ” ê²ƒì´ ì•„ë‹Œ multipart/form-dataê°€ ë“¤ì–´ê°€ê²Œ ë©ë‹ˆë‹¤. 

 ì¦‰, ë°ì´í„°ë¥¼ Bodyì— ë„£ì–´ ë³´ë‚¼ ë•Œ í¼ ë°ì´í„°ê°€ ì—¬ëŸ¬ ë¶€ë¶„ìœ¼ë¡œ ë‚˜ë‰˜ì–´ì„œ ì„œë²„ë¡œ ì „ì†¡í•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤. ì´ë ‡ê²Œ ë³´ë‚´ê¸° ë•Œë¬¸ì— 2ì¢…ë¥˜ ì´ìƒì˜ ë°ì´í„°ë¥¼ êµ¬ë¶„í•´ì„œ ë„£ëŠ” ê²ƒì´ ê°€ëŠ¥í•˜ë‹¤.

> âœ”ï¸ Content-Type : multipart/form-data
>
> ëª¨ë“  ë¬¸ìë¥¼ ì¸ì½”ë”©í•˜ì§€ ì•ŠìŒì„ ëª…ì‹œí•¨. ì´ ë°©ì‹ì€ <form> ìš”ì†Œê°€ íŒŒì¼ì´ë‚˜ ì´ë¯¸ì§€ë¥¼ ì„œë²„ë¡œ ì „ì†¡í•  ë•Œ ì£¼ë¡œ ì‚¬ìš©í•œë‹¤.
>
> multipart/form-dataëŠ” í¼ë°ì´í„°ê°€ ì—¬ëŸ¬ ë¶€ë¶„ìœ¼ë¡œ ë‚˜ë‰˜ì–´ ì„œë²„ë¡œ ì „ì†¡ë˜ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.
>
> ì¦‰, í˜•íƒœë¥¼ ë³´ê²Œ ë˜ë©´ ë¦¬ìŠ¤íŠ¸ í˜•ì‹ìœ¼ë¡œ ë˜ì–´ ìˆì–´ì„œ í•œ íŒŒì¼, íŒŒì¼ì„ ë‚˜ëˆ„ì–´ì„œ ë¶™ì—¬ì•¼í•œë‹¤.

<br>

 Alamofireì˜ uploadTaskì˜ multipartform ë°ì´í„°ë¥¼ ë³´ë‚¼ ìˆ˜ ìˆëŠ” í˜•ì‹ì´ êµ¬í˜„ë˜ì–´ ìˆëŠ” ê²ƒì„ ì‚¬ìš©í•˜ì—¬ ì„œë²„ì™€ í†µì‹ í•˜ì˜€ë‹¤. ìš°ì„  í†µì‹ ì„ ìœ„í•´ í•´ì•¼í•  ì‘ì—…ë“¤ì´ ìˆë‹¤.

ğŸ‘‰ Alamofire 4.8version ì‚¬ìš©

ğŸ‘‰ API êµ¬ì„± ì™„ë£Œ

1ï¸âƒ£ ì„œë²„ í†µì‹ ì„ ìœ„í•œ URL ì£¼ì†Œ ì €ì¥

2ï¸âƒ£ í†µì‹ ì„ í†µí•´ ë°›ì„ Response ê°ì²´ ìƒì„±

3ï¸âƒ£ Alamofire ì‚¬ìš© Upload ë©”ì†Œë“œ ì‘ì„±

<br>

âœ”ï¸ ì„œë²„ í†µì‹ ì„ ìœ„í•œ URL ì£¼ì†Œ ì €ì¥

```swift
struct APIConstants {
  static let baseURL = "http://13.209.144.115:3002"
  static let profileURL = APIConstants.baseURL + "/user/profile"
}
```

<br>

âœ”ï¸ í†µì‹ ì„ í†µí•´ ë°›ì„ Response ê°ì²´ ìƒì„±

```swift
// APIë¬¸ì„œë¥¼ ì°¸ê³ í•´ì„œ Request ê°ì²´ë¥¼ ë§Œë“¤ì–´ì£¼ì–´ì•¼ í•œë‹¤.
// Profile ì‘ì—…ì„ ìœ„í•´ ë°›ì€ API ë¬¸ì„œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì‘ì„±í•˜ì˜€ë‹¤.
struct ProfileData: Codable {
  var status: Int
  var success: Bool
  var message: String
  var data: [UserProfile]?
  
  enum CodingKeys: String, CodingKey {
    case status = "status"
    case success = "success"
    case message = "message"
    case data = "data"
  }
  
  // CodingKey í”„ë¡œí† ì½œì„ ì´ìš©í•´ Keyê°’ì´ ë“¤ì–´ì˜¤ì§€ ì•Šì€ ê²½ìš°ë¥¼ ì²˜ë¦¬í•´ì£¼ì—ˆë‹¤
  init(from decoder: Decoder) throws {
    let values = try decoder.container(keyedBy: CodingKeys.self)
    status = (try? values.decode(Int.self, forKey: .status)) ?? -1
    success = (try? values.decode(Bool.self, forKey: .success)) ?? false
    message = (try? values.decode(String.self, forKey: .message)) ?? ""
    data = (try? values.decode([UserProfile].self, forKey: .data)) ?? nil
  }
}

struct UserProfile: Codable {
  var name: String
  var email: String
  var phone: String
  var profile: String
}
```

<br>

âœ”ï¸ Alamofire ì‚¬ìš© Upload ë©”ì†Œë“œ ì‘ì„±

```swift
func uploadImage(_ token: String, completion @escaping (NetworkResult<Any>) -> Void) {
  // Content Type ==> multipart/form-data ìƒì„±
  let headers: HTTPHeaders = [
    "Content-Type" : "multipart/form-data",
    "jwt" : token
  ]
  
  Alamofire.upload(multipartFormData: { 
    multipartFormData in
    let logoImageData = UIImage(named: "mainLogo")!.jpegData(compressionQuality: 1.0)!
    multipartFormData.append(logoImageData, withName: "profile", fileName: "íŒŒì¼ì´ë¦„", mimeType: "image/jpeg")
  }, usingThreshold: UInt64.init(), to: APIConstants.profileURL, method: .post, headers: headers, encodingCompletion: { 
    (result) in
    switch result {
      case .success(let upload, _, _):
      	// Uploadê°€ ì§„í–‰ë˜ëŠ” ê³¼ì •ì„ ë°±ë¶„ìœ¨ë¡œ í‘œí˜„í•˜ê¸° ìœ„í•œ ì½”ë“œ
      	upload.uploadProgress(closure: { 
          (progress) in
          print(progress.fracgtionCompleted)
        })
      	
      	upload.responseData { 
          response in
          print(response.result.value)
        }
      case .failure(let error): print(error.localizedDescription)
    }
  
  })
}
```

> **withName** : Multipart Form ë°ì´í„°ë¥¼ ë³´ë‚¼ ë•Œ, ì§€ì •í•  Keyê°’ì„ ë„£ì–´ì¤€ë‹¤. 
>
> **fileName** : ë°ì´í„°ë¥¼ ë³´ë‚¼ Bodyì™€ëŠ” ê´€ë ¨ì—†ì´ ë³´ë‚´ëŠ” íŒŒì¼ì˜ ì´ë¦„ì„ ì§€ì •í•  ìˆ˜ ìˆë‹¤.
>
> **mimeType** : ë°ì´í„°ë¥¼ ë³´ë‚¼ ë•Œ, ë³€í™˜ ì‹œ ì‚¬ìš©í•  ë°ì´í„° í˜•ì‹ì„ ì •ì˜í•œë‹¤.
>
> ğŸ‘‰ ***MIMEì´ë€?*** ì›ë˜ëŠ” E-mailì— ì‚¬ìš©í•˜ê¸° ìœ„í•´ ë“±ì¥í–ˆì§€ë§Œ ì§€ê¸ˆì€ HTTP í†µì‹ ì—ì„œ ì „ì†¡ ë°ì´í„°ë¥¼ í‘œí˜„í•˜ê¸° ìœ„í•´ì„œë„ ì‚¬ìš©í•˜ê³  ìˆë‹¤. ë©”ì„¸ì§€ì˜ ì¢…ë¥˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” Content-Typeê³¼ ê°™ì€ ì¶”ê°€ì ì¸ E-mail í—¤ë”ë¥¼ ì •ì˜í•˜ëŠ” ê²ƒì´ë‹¤. 
>
>  ë°‘ì˜ ê·¸ë¦¼ì„ ë³´ë©´ ê° í—¤ë”ë¡œ í‘œì‹œí•˜ëŠ” ë°ì´í„°ì˜ í˜•ì‹ì´ ë‚˜ì™€ìˆë‹¤. ì—¬ê¸°ì„œ ì „ì†¡ ì‹œ ì¤‘ê°„ë‹¨ê³„ì—ì„œ í•´ë‹¹ íƒ€ì…ì„ í†µí•´ ì–´ë–¤ íŒŒì¼ë¡œ ë³€í™”í• ì§€ ì•Œ ìˆ˜ ìˆê³  ì´ë¥¼ ë³€í™˜í•´ì„œ ì‚¬ìš©í•œë‹¤.
>
> <img src="../images/mimeType.png">
>
> **usingThreshold** : ??
>
> **encodingCompletion** : MultipartForm ë°ì´í„°ë¡œ ì¸ì½”ë”©ì´ ëë‚œ ë’¤ì— ì‹¤í–‰ë˜ëŠ” ì½”ë“œì´ë‹¤.

